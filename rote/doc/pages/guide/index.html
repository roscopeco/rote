<% @page_title = 'User guide' %>

<a name='top'></a>
*This guide is still very much under construction!*

It is assumed that you have installed Rote already. If not, please
consult the <a href="<%= link_rel '/rdoc/files/README.html' %>">README</a> 
for installation instructions.

<%= section 3, 'Conventions', false %>

*Task names* - Rote's standard tasks are always referred to with the base-name
_doc_ , e.g. @doc_pages@, @doc_clean@, and just plain @doc@. This is the prefix
used by the built-in Rakefile, but since it can be changed when using Rote in
your own Rake builds you should of course substitute whatever is appropriate 
if you have chosen to modify it.

<%= section 3, 'Starting out with Rote' %>

<%= section 4, 'Creating a project', false %>

To get started quickly, we'll use the built-in project template, which provides
a standard Rote directory tree with a single page, and Rakefile ready for
customisation. The template gives a convenient way to get started on a new
Rote project. To invoke it, just type:

<p><pre><code>        rote create someproject</code></pre></p>

If all goes well, you should see a single line (@cp_r ...@) indicating that
Rote copied the template to your specified directory (@someproject@ in this
case). This directory will have the following layout:

<p><code><pre>  
  someproject
  |
  |--> Rakefile 
  |
  |--> doc
  |    |--> res
  |    |    |--> images
  |    |    |--> rote-tiny.png
  |    |
  |    |--> layouts
  |    |    |--> normal.html
  |    | 
  |    |--> pages
  |         |--> COMMON.rb
  |         |--> index.html
  |         |--> index.rb
			  
</pre></code></p>

Template sources under the 'pages' directory may have any extension (except
@rb@), and will be rendered to that same name under the output directory. 
See the section on Layouts below for details on layout name resolution.

Ruby source is optional, and allows you to define instance variables and 
methods on a Page instance. COMMON.rb is applied to all pages in a given
directory. See <%= section_link 'creating templates', 'the section on templates' %>
for more information on the specifics.

To build the sample page, simply type @rote@ or @rake@ from the top-level
directory. This will start the default @doc@ task to transform all 
modified pages / resources (everything, in this case).

The README included with the project template has further information
about build options and available tasks, as well as pointers to possible
next steps.

<%= section 4, 'From the command-line' %>

If you are generating a standalone documentation set (i.e. not as part of 
some wider build) then you don't need to worry about writing a @Rakefile@ -
you can use the built-in build via the @rote@ command. This works with
a standard directory layout, and wraps invocation of @rake@ to handle
setting up library dependencies and generation of appropriate tasks.

The command-line wrapper expects the above layout, and requires no direct
configuration. To generate an entire documentation set, simply run:

<p><pre><code>        rote</code></pre></p>
	
from the top-level directory (@project@ in the example above), you should get
a 'html' directory created with the (transformed) templates, and any 
resources should be copied as necessary. 

Being based on Rake, Rote supports last-modified checking, and provides an
individual file task for each page in your doc set. For example, running 
the 'rote' command again with no options will cause it to exit almost
immediately, since all output is up to date. If you change a file, and run
rote again, then just that file will be updated. There are a few caveats
with this (see <%= section_link 'Final notes', 'the notes section' %>).

The file tasks are named for the target files, so for example to generate
just the top-level index.html (regardless of whether it's been modified)
you'd run:

<p><pre><code>        rote html/index.html</code></pre></p>

The @clobber@ task supports deleting all output files to start from scratch:

<p><pre><code>        rote clobber</code></pre></p>

Of course, multiple file or task names (or a mixture) can be specified.
You can get a list of valid tasks in the current context with:

<p><pre><code>        rote --tasks</code></pre></p>
	
Further command-line usage information is available with:
	
<p><pre><code>        rote --usage</code></pre></p>
	
and Unix installations performed with @install.rb@ should also make a
manpage available for the @rote@ command.

<%= section 4, 'From your Rakefile' %>

If you are wanting to build documentation as part of a larger build process, or
commandline setup, then you'll want to get started on integrating Rote with 
your own (existing) @Rakefile@. Fortunately, this is very easy to do. Try 
something like:

<pre><code>
	# Rakefile
	require 'rote'
	
	ws = Rote::DocTask.new(:doc) { |site| 
	  site.output_dir = 'html'
	  site.layout_dir = 'doc/layouts'
	
	  site.pages.dir = 'doc/pages'
	  site.pages.include('**/*')  
		  
	  site.res.dir = 'doc/res/'
	  site.res.include('**/*.png')
	  site.res.include('**/*.gif')
	  site.res.include('**/*.jpg')
	  site.res.include('**/*.css')
	}	
</code></pre>
	
Save this as @Rakefile@, and fire up:

<pre><code>        rake doc</code></pre>

If all goes well, you should see each command and transformation output to your
console as Rote runs. 

*Note* that it's safe to include all files in the @pages@ list, since @rb@ 
files are implicitly excluded (as page code).

<%= section 3, 'Creating templates' %>

<%= section 4, 'The Basics', false %>

As mentioned, templates are simply text files in the @doc/pages@ directory. The
layout below that directory is retained when transforming pages, and is
also used to provide simple hierarchical structure to the common page code.

By default, any file with an extension other than @rb@ will be processed
as a page template (with it's associated ruby source). The output will have
the same filename and path, relative to the output directory.

<%= section 4, 'Applying formatting' %>

If you're generating HTML, you'll probably want to use some plaintext 
formatting, rather than writing HTML by hand. Rote directly supports
the Textile, Markdown and Rdoc textual formatting styles.
The formatting applied to a given page is controlled by that page's @format_opts@
array. All three are disabled by default - to enable formatting you must add
appropriate symbols to the array, for example in page code or COMMON.rb:

<p><pre><code>        format_opts << :textile << :markdown << :rdoc</code></pre></p>

This can be done in page code, COMMON.rb, or even inside the template itself.
See <%= section_link 'template code and erb', 'the section on template code' %> 
for more information on adding code to your templates. Obviously you don't have 
to use all three, and order isn't significant - formatting is applied as Textile, 
then Markdown, then Rdoc.
	
*Some additional notes on formatting*

  * You cannot directly assign to @format_opts@, from page code since Ruby 
    interprets assignments with no receiver as local variable sets rather than
    method calls, resulting in much head scratching as to why your options are 
    being ignored. Always use the << :opt syntax.
    
  * Note that *Formatting is applied _after_ any ERB has been evaluated.*
    This allows you to output formatting from your code and have it rendered
   	properly.

  * that the options you supply are passed directly to RedCloth, so you can
    exercise much more control over the formatting by using the feature-specific
    symbols defined by RedCloth, rather than the blanket :textile and :markdown
    symbols.

<%= section 4, 'Template code and ERB' %>

All templates may contain embedded Ruby code (ERB), delimited by the standard
&lt;&#37; ... &#37;&gt; (for executed code) and &lt;&#37;= ... &#37;&gt; (for 
output) tags. Any (valid) Ruby code may be placed in the templates, and 
variables may be defined to allow information to be passed into templates.
There are four places where you might define such variables. The following 
is in order of evaluation:

* This directory's COMMON.rb, or the parent directory's COMMON.rb if
  @inherit_common@ is used.
* This page's ruby code, _basename_.rb
* In a block passed to Page.new
* In the template itself

When a @Rote::Page@ instance is created, Rote looks for these, and if found
evaluates them, in order, in the same binding as the template is later rendered
in (i.e. the @Page@ instance binding). Therefore, you can define
instance variables to pass data around, or even helper methods if you wish.

<%= section 4, 'Layout' %>

Layouts are stored under the @doc/layouts@ directory (by default). They may
be organised into subdirectories, but this hierarchy is not connected to
the hierarchy in @pages@. To apply a layout to a page, simply call the
@Rote::Page.layout@ method from code applied to that page, passing the
base-name (and path, relative to @layouts@, if used). If no extension is
specified, then the same extension as the page itself is assumed. Examples:

  * layout 'one'
  * layout 'main/wide'
  * layout 'dark.txt'
  * &lt;&#37; layout 'my' &#37;&gt;
  
_*Note* the absence of the = sign   in the ERB tag in the last example,_
_indicating that this is code to be executed rather than code that should_
_generate output._

With that done, Rote would first render the template text (including textile)
and set the Page instance variable @\@content_for_layout@ before rendering 
the layout (in which textile is currently not supported). The layout is
responsible for inserting the rendered template where appropriate, with
e.g.:

  * &lt;&#37;= @content_for_layout &#37;&gt;

This pattern shouldn't be unfamiliar. Again, note that Rote doesn't mandate 
HTML, despite the appearance from the ERB tags - any (textual) format can
be templated and laid out.

<%= section 3, 'Resources' %>

Of course, you're likely to have resources for your site (images, sounds, etc)
and you'll need to copy them over to the target too. Such resources should be
placed under @doc/res@ (with the commandline setup) or in your specified @res@
directory (from a Rakefile).

As you'd expect, the directory layout beneath @res@ should mirror that of the 
output, and will be preserved during the copy. Resources are copied only if
necessary (determined by existence and last-modified timestamp), in a similar
way to pages.

<%= section 3, 'Source monitoring' %>

When making changes to a documentation set, you frequently need to render out
your changes to check formatting or ensure something works correctly. In this
situation it's inconvenient to keep dropping out to your shell to run @rote@
(or @rake@) manually, particularly when making a lot of incremental changes.

Fortunately, Rote provides a simple mechanism for monitoring your documentation
source and automatically performing updates as needed. Simply specify the 
@doc_monitor@ task and Rote will go into a loop, periodically running the
top-level _doc_ task which will transform / copy any pages or resources that
have been modified. It will of course take notice of any custom file or directory
dependencies you add to the doc task (e.g. to generate RDoc as part of a
website), and in turn monitor their dependent files too (for example rebuilding
the RDoc if you modify a source file). It does *not* however attempt to track
format-specific dependencies _between_ resources (such as which pages use which
CSS), since this would imply some knowledge of the format in use. In practice
this means that you may need to trigger a clean build after updating such
resources, although it is actually fairly easy to set up this kind of 
relationship by specifying that certain file-tasks relating to pages depend 
on the appropriate file-tasks representing the resources (for instance).

By default, @monitor@ checks for updates approximately once
per second, but you can specify a custom value _when using a Rakefile_ by
setting @monitor_interval@ in the block passed to @DocTask.new@.

*Note* that the monitor functionality is deliberately kept simple with respect
to IO and concurrency, reflecting the fact that output files are rarely
anything more than that - it would be almost pointless to complicate the
way monitoring works with any kind of semaphore or file-locking scheme.
Of course if this does cause problems in your particular scenario, let me know
because it just might make me reconsider.

When you're done with Rote simply hit CTRL-C (or use @kill@) to stop monitoring
and exit.

<%= section 4, 'Auto-refresh task' %>

When using Source monitoring, it's often handy to be able to inform some other
program that something has changed. For example, you may want to automatically
refresh your browser after changed HTML is rendered. Rote supports this via
the @doc_refresh@ task, which is triggered whenever @doc_monitor@ finds changes
in your source set (_after_ rendering, of course).

The following (Mac) example uses OSA script to refresh the Safari browser when
your rendered documentation changes:
<pre><code>
	require 'osx/aeosa'
	
	task :doc_refresh do 
		OSX.do_osascript('tell application "Safari" to do javascript "window.location.reload();" in document 1')	
	end
</code></pre>

As with all rake tasks, multiple actions can be associated, and you can of course
add prerequisites to the @refresh@ task as with any other Rake task.

<%= section 3, 'Defining additional tasks' %>

The command-line build will automatically look for a file in the top-level
directory (above @doc@) named @local.rf@. If found, this file will be 
evaluated by Rake, making any tasks defined within it available to your
build. This can be used to define an <%= section_link 'auto-refresh task' %>
for the <%= section_link 'source monitoring', 'monitor' %> feature, for example,
or to define tasks to publish your site (most likely using one of Rake's 
directory publishers).

<%= section 3, 'Publishing' %>

Rote does not provide any direct support for publishing your site at present,
relying on you to configure an appropriate publish task if required, using
the publishers supplied with Rake (in @rake/contrib@), or your own. This 
allows maximum flexibility, and allows Rote to concentrate on creating your 
documents.

<%= section 3, 'Final notes' %>

Currently, there isn't enough checking involved on source resources when
building pages - Basically, only templates are considered when Rake decides
what to update. If you change common or page code you'll need to run:
	
<p><pre><code>        rote clobber</code></pre></p>
		
to make sure everything gets updated. This will also apply if you have
interdependencies between pages and resources, but in that situation you
_could_ work around it if you wished by manually (!) specifying the 
appropriate resources as dependencies to the appropriate page task.
Such configuration is beyond the scope of this manual - see 
"Rake's Documentation":http://rake.rubyforge.org/ for information on
dependency configuration and resolution in Rake.

[<%= section_link 'Top' %>]
